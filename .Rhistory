labs(title="SparNord ATM transactions in 2017",
subtitle = "Density of ATM placement")
grid.arrange(p1,p2, nrow=1)
s1 <- data %>% group_by(month) %>% summarize(n=n()/1000) %>%
ggplot(aes(month,n))   + geom_col(fill=base, width=0.8)     +
labs(title = "By month") +
theme(axis.text.x = element_text(angle = 90, vjust=-0.1))
s2 <- data %>% group_by(day) %>% summarize(n=n()/1000) %>%
ggplot(aes(day,n)) + geom_col(fill=base, color=base)         +
labs(title = "By day")
s3 <- data %>% group_by(weekday) %>% summarize(n=n()/1000) %>%
ggplot(aes(weekday,n)) + geom_col(fill=base, width=0.8) +
labs(title = "By weekday") +
theme(axis.text.x = element_text(angle = 90, vjust=-0.1))
s4 <- data %>% group_by(hour) %>% summarize(n=n()/1000) %>%
ggplot(aes(hour,n))    + geom_col(fill=base, color=base)       +
labs(title = "By hour") +
scale_x_continuous(breaks=c(0,3,6,9,12,15,18,21,24))
s5 <- data %>% filter(currency == "EUR") %>% group_by(weekday) %>% summarize(n=n()/1000) %>% ggplot(aes(weekday,n)) + geom_col(fill=base, width=0.8)  + labs(title="By weekday - Euro")+
theme(axis.text.x = element_text(angle = 90, vjust=-0.1))
s6 <- data %>% filter(currency == "EUR") %>% group_by(month) %>% summarize(n=n()/1000) %>% ggplot(aes(month,n)) + geom_col(fill=base, width=0.8)  + labs(title="By month - Euro")+
theme(axis.text.x = element_text(angle = 90, vjust=-0.1))
s7 <- data %>% filter(currency == "EUR") %>% group_by(day) %>% summarize(n=n()/1000) %>% ggplot(aes(day,n)) + geom_col(color = base, fill = base) +
labs(title="By day - Euro")
s8 <- data %>% filter(currency == "EUR") %>% group_by(hour) %>% summarize(n=n()/1000) %>% ggplot(aes(hour,n)) + geom_col(color = base, fill = base) + labs(title="By hour - Euro") +
scale_x_continuous(breaks=c(0,3,6,9,12,15,18,21,24))
grid.arrange(s1,s3,s2,s4,s6,s5,s7,s8, nrow=2)
s1 <- data %>% group_by(month) %>% summarize(n=n()/1000) %>%
ggplot(aes(month,n))   + geom_col(fill=base, width=0.8)     +
labs(title = "By month", x="") +
theme(axis.text.x = element_text(angle = 90, vjust=-0.1))
s2 <- data %>% group_by(day) %>% summarize(n=n()/1000) %>%
ggplot(aes(day,n)) + geom_col(fill=base, color=base)         +
labs(title = "By day", x="")
s3 <- data %>% group_by(weekday) %>% summarize(n=n()/1000) %>%
ggplot(aes(weekday,n)) + geom_col(fill=base, width=0.8) +
labs(title = "By weekday", x="") +
theme(axis.text.x = element_text(angle = 90, vjust=-0.1))
s4 <- data %>% group_by(hour) %>% summarize(n=n()/1000) %>%
ggplot(aes(hour,n))    + geom_col(fill=base, color=base)       +
labs(title = "By hour", x="") +
scale_x_continuous(breaks=c(0,3,6,9,12,15,18,21,24))
s5 <- data %>% filter(currency == "EUR") %>% group_by(weekday) %>% summarize(n=n()/1000) %>% ggplot(aes(weekday,n)) + geom_col(fill=base, width=0.8)  + labs(title="By weekday - Euro", x="")+
theme(axis.text.x = element_text(angle = 90, vjust=-0.1))
s6 <- data %>% filter(currency == "EUR") %>% group_by(month) %>% summarize(n=n()/1000) %>% ggplot(aes(month,n)) + geom_col(fill=base, width=0.8)  + labs(title="By month - Euro", x="")+
theme(axis.text.x = element_text(angle = 90, vjust=-0.1))
s7 <- data %>% filter(currency == "EUR") %>% group_by(day) %>% summarize(n=n()/1000) %>% ggplot(aes(day,n)) + geom_col(color = base, fill = base) +
labs(title="By day - Euro", x="")
s8 <- data %>% filter(currency == "EUR") %>% group_by(hour) %>% summarize(n=n()/1000) %>% ggplot(aes(hour,n)) + geom_col(color = base, fill = base) + labs(title="By hour - Euro", x="") +
scale_x_continuous(breaks=c(0,3,6,9,12,15,18,21,24))
grid.arrange(s1,s3,s2,s4,s6,s5,s7,s8, nrow=2)
data %>% filter(currency =="EUR") %>% group_by(day, month) %>% summarize(n=n()) %>% ggplot(aes(day, n)) + geom_col(fill=base, color=base) + facet_wrap(~month)  + labs(title="The number of Euro withdrawals on each date", subtitle="We see how the summer is an active period, while january is almost empty")
table(fdata$Euro, fdata$Id) %>%
prop.table(margin=2) %>%
as.data.frame %>%
filter(Var1==T) %>%
ggplot(aes(reorder(Var2, Freq), Freq)) +
geom_col(fill=base, color=base) +
labs(x="ATM id", legend="Euro", title="Percentage of EURO transactions by each ATM machine",
subtitle="Machine 99 has almost 50% Euro transactions, but it's an internal ATM") +
theme(axis.text.x=element_text(size=4))
data %>% filter(atm_id == 99) %>% summarize(n=n())
#fdata
a3 <- ggplot(fdata, aes(x=fdata$Airportdist)) + geom_histogram(binwidth=3, col = base, fill = base) + labs(title="Distance to airport")
a4 <- ggplot(fdata, aes(x=fdata$Airportdist, stat(density))) + geom_histogram(binwidth=3, col = base, fill = base) +
facet_wrap(~Euro, nrow=2) + labs(title="Distance to airport by Euro")
grid.arrange(a3,a4, nrow=1)
a4 <- ggplot(fdata, aes(x=fdata$Airportdist, stat(density))) + geom_histogram(binwidth=3, col = base, fill = base) +
facet_wrap(~Euro, nrow=2) + geom_line(aes(y = ..density..), stat = 'density') + labs(title="Distance to airport by Euro", x="Distance to airport")
grid.arrange(a3,a4, nrow=1)
a4 <- ggplot(fdata, aes(x=fdata$Airportdist, stat(density))) + geom_histogram(binwidth=3, col = base, fill = base) +
facet_wrap(~Euro, nrow=2) + geom_area(aes(y = ..density..), stat = 'density') + labs(title="Distance to airport by Euro", x="Distance to airport")
grid.arrange(a3,a4, nrow=1)
a4 <- ggplot(fdata, aes(x=fdata$Airportdist, stat(density))) +
facet_wrap(~Euro, nrow=2) + geom_area(aes(y = ..density..), stat = 'density', fill=base) + labs(title="Distance to airport by Euro", x="Distance to airport")
grid.arrange(a3,a4, nrow=1)
a3 <- ggplot(fdata, aes(x=fdata$Airportdist)) +
geom_histogram(binwidth=3, col = base, fill = base) +
labs(title="Distance to airport total", x="Distance to airport")
grid.arrange(a3,a4, nrow=1)
fdata %>%
group_by(Euro) %>%
summarize(MeanDistance = mean(Airportdist)) %>% kable %>% kable_styling("condensed", "bordered")
#Euro/Region
fdata %>% group_by(Region, Euro) %>% summarize(n=n()) %>% mutate(freq = n/sum(n)) %>% filter(Euro==T) %>%
ggplot(aes(reorder(Region,freq),freq)) + geom_col(fill=base) + labs(title="The amount of Euro withdraws by each region", x="") + geom_text(aes(y=freq + 0.002,label=round(freq*100,2)))
tab <- table(fdata$Holliday, fdata$Euro)
summary(tab)
a2 <- fdata %>% group_by(Holliday, Euro) %>% summarize(n=n()) %>% mutate(freq = n/sum(n)) %>% filter(Euro==T) %>%
ggplot(aes(reorder(Holliday,freq),freq)) + geom_col(fill=base) + labs(title="Holiday", x="") + geom_text(aes(y=freq + 0.002,label=round(freq*100,2)))
#Customer/Euro
a5 <- fdata %>% group_by(Customer, Euro) %>% summarize(n=n()) %>% mutate(freq = n/sum(n)) %>% filter(Euro==T) %>%
ggplot(aes(Customer,freq)) + geom_col(fill=base) + labs(title="Customer", x="") + geom_text(aes(y=freq + 0.002,label=round(freq*100,2)))
#Weekend/Euro
a6 <- fdata %>% group_by(Weekend, Euro) %>% summarize(n=n()) %>% mutate(freq = n/sum(n)) %>% filter(Euro==T) %>%
ggplot(aes(Weekend,freq)) + geom_col(fill=base) + labs(title="Weekend", x="") + geom_text(aes(y=freq + 0.002,label=round(freq*100,2)))
#Payout/Euro
a7 <- fdata %>% group_by(Payout, Euro) %>% summarize(n=n()) %>% mutate(freq = n/sum(n)) %>% filter(Euro==T) %>%
ggplot(aes(Payout,freq)) + geom_col(fill=base) + labs(title="Payout", x="") + geom_text(aes(y=freq + 0.002,label=round(freq*100,2)))
grid.arrange(a2, a5,a6,a7, nrow=1)
fdata %>% group_by(Card, Euro) %>% summarize(n=n()) %>% mutate(freq = n/sum(n)) %>% filter(Euro==T) %>%
ggplot(aes(reorder(Card,freq),freq)) +
geom_col(fill=base) +
labs(title="Euro-withdraws as percent of all the trans", x="") +
geom_text(aes(y=freq + 0.002,label=round(freq*100,2)))
vars <- c("day","hour","atm_id","atm_street_number","atm_zipcode","atm_lat",
"atm_lon","message_code","weather_lat","weather_lon","weather_city_id",
"temp","pressure","humidity","wind_speed","wind_deg","rain_3h",
"clouds_all","weather_id")
bATM[,vars] %>%
aggr(col = c('white',base),
labels = names(sATM[,vars]),
cex.axis = 0.5,
gap = 0.5,
ylab=c("Missing data","Pattern"))
vars <- c("day","hour","atm_id","atm_street_number","atm_zipcode","atm_lat",
"atm_lon","message_code","weather_lat","weather_lon","weather_city_id",
"temp","pressure","humidity","wind_speed","wind_deg","rain_3h",
"clouds_all","weather_id")
bATM[,vars] %>%
aggr(col = c('white',base),
labels = names(bATM[,vars]),
cex.axis = 0.5,
gap = 0.5,
ylab=c("Missing data","Pattern"))
ggcorr(bATM[vars], label = TRUE, label_size = 2, label_round = 2, hjust = 0.90) +
labs(title="Correlation among variables", fill="Correlation") +
scale_fill_gradient2(midpoint=0, low=base, mid="white", high=base)+
coord_cartesian(expand=T)
vars2 <- c("day","hour","atm_id","atm_street_number","atm_zipcode","atm_lat",
"atm_lon","weather_city_id","temp","pressure","humidity","wind_speed",
"wind_deg","clouds_all", "weather_id")
a <- summary(pca)
vars2 <- c("day","hour","atm_id","atm_street_number","atm_zipcode","atm_lat",
"atm_lon","weather_city_id","temp","pressure","humidity","wind_speed",
"wind_deg","clouds_all", "weather_id")
pca <- bATM[,vars2] %>%
map_dfc(.f = scale) %>%
prcomp(rank=4)
a <- summary(pca)
df1 <- a$importance[2,] %>% as_tibble %>% gather(variable, value) %>% mutate(type="Change", N=c(1:nrow(.)))
df2 <- a$importance[3,] %>% as_tibble %>% gather(variable, value) %>% mutate(type="Accumulated", N=c(1:nrow(.)))
rbind(df1,df2) %>% as_tibble %>%
ggplot(aes(N, value)) +
geom_line(size=1.5, color=base) +
geom_point(size=3, shape=21, fill="white", color=base, stroke=2) +
facet_wrap(~type, scale="free") + scale_x_continuous(breaks=c(0:15)) +
labs(title="Screeplot: Number of factors in PCA", x="Number of factors")
loadings <- pca$rotation %>%
abs() %>%
sweep(2, colSums(.), "/") %>%
as.data.frame %>%
rownames_to_column("name")
loadings[,-1] <- apply(loadings[,-1], MARGIN = 2, FUN = round, digits=2)
a <- loadings %>% dplyr::select(name, PC1) %>% arrange(desc(PC1)) %>% head(6)
b <- loadings %>% dplyr::select(name, PC2) %>% arrange(desc(PC2)) %>% head(6)
c <- loadings %>% dplyr::select(name, PC3) %>% arrange(desc(PC3)) %>% head(6)
d <- loadings %>% dplyr::select(name, PC4) %>% arrange(desc(PC4)) %>% head(6)
kable(cbind(a,b,c,d)) %>% kable_styling("condensed", "bordered")
wss <- 0
for (i in 1:15) {
wss[i] <- kmeans(bATM[,vars2], centers = i, nstart=20)$tot.withinss
}
wss <- 0
for (i in 1:15) {
wss[i] <- kmeans(sATM[,vars2], centers = i, nstart = 10)$tot.withinss
}
wss <- 0
for (i in 1:15) {
wss[i] <- kmeans(bATM[,vars2], centers = i, nstart = 5)$tot.withinss
}
scree <- tibble(wss, N = 1:15)
ggplot(scree, aes(N, wss)) +
geom_line(size=1.5, color=base) +
geom_point(size=3, shape=21, fill="white", color=base, stroke=2) +
scale_x_continuous(breaks=c(1:15)) +
labs(title="Screeplot: Number of clusters", x="Number of clusters", y="WSS")
set.seed(250920198)
km <- bATM[,vars2] %>%
scale() %>%
kmeans(centers = 4, nstart = 20)
df <- pca$x %>% as_tibble %>% select(PC1, PC2)
df$cluster <- km$cluster
eigen <- pca$rotation
points <- (km$centers) %*% (eigen) %>%
as_tibble %>%
mutate(N=c("PC1", "PC2", "PC3", "PC4")) %>%
gather(variable, value,-N) %>%
spread(key = N, value = value) %>%
mutate(variable2=c(2,1,3,4))
df %>%
ggplot(aes(PC1,PC2)) +
geom_point(aes(color=as.factor(cluster)), alpha=0.3, show.legend = F) +
scale_color_tableau(palette = "Classic Cyclic", type = "regular") +
scale_fill_tableau(palette = "Classic Cyclic", type = "regular") +
geom_point(data=points, aes(PC2,PC1, fill=as.factor(variable2)), inherit.aes = F, size=5, shape=21, color="black") +
labs(title="Kmeans clusters displayed in first two PCA components",
subtitle="Centroids are created by multiplying the centers by the eigen vector from PCA",
fill = "Clusters")
load(file = "generated_data/sATM.Rdata")
set.seed(250920198)
km <- sATM[,vars2] %>%
scale() %>%
kmeans(centers = 4, nstart = 20)
df <- pca$x %>% as_tibble %>% select(PC1, PC2)
df$cluster <- km$cluster
eigen <- pca$rotation
points <- (km$centers) %*% (eigen) %>%
as_tibble %>%
mutate(N=c("PC1", "PC2", "PC3", "PC4")) %>%
gather(variable, value,-N) %>%
spread(key = N, value = value) %>%
mutate(variable2=c(2,1,3,4))
df %>%
ggplot(aes(PC1,PC2)) +
geom_point(aes(color=as.factor(cluster)), alpha=0.3, show.legend = F) +
scale_color_tableau(palette = "Classic Cyclic", type = "regular") +
scale_fill_tableau(palette = "Classic Cyclic", type = "regular") +
geom_point(data = points, aes(PC2,PC1, fill = as.factor(variable2)),
inherit.aes = F, size = 5, shape = 21, color = "black") +
labs(title = "Kmeans clusters displayed in first two PCA components",
subtitle = "Centroids are created by multiplying the centers by the eigen vector from PCA",
fill = "Clusters")
vars2 <- c("day","hour","atm_id","atm_street_number","atm_zipcode","atm_lat",
"atm_lon","weather_city_id","temp","pressure","humidity","wind_speed",
"wind_deg","clouds_all", "weather_id")
pca <- sATM[,vars2] %>%
map_dfc(.f = scale) %>%
prcomp(rank=4)
a <- summary(pca)
df1 <- a$importance[2,] %>% as_tibble %>% gather(variable, value) %>% mutate(type="Change", N=c(1:nrow(.)))
df2 <- a$importance[3,] %>% as_tibble %>% gather(variable, value) %>% mutate(type="Accumulated", N=c(1:nrow(.)))
rbind(df1,df2) %>% as_tibble %>%
ggplot(aes(N, value)) +
geom_line(size=1.5, color=base) +
geom_point(size=3, shape=21, fill="white", color=base, stroke=2) +
facet_wrap(~type, scale="free") + scale_x_continuous(breaks=c(0:15)) +
labs(title="Screeplot: Number of factors in PCA", x="Number of factors")
loadings <- pca$rotation %>%
abs() %>%
sweep(2, colSums(.), "/") %>%
as.data.frame %>%
rownames_to_column("name")
loadings[,-1] <- apply(loadings[,-1], MARGIN = 2, FUN = round, digits=2)
a <- loadings %>% dplyr::select(name, PC1) %>% arrange(desc(PC1)) %>% head(6)
b <- loadings %>% dplyr::select(name, PC2) %>% arrange(desc(PC2)) %>% head(6)
c <- loadings %>% dplyr::select(name, PC3) %>% arrange(desc(PC3)) %>% head(6)
d <- loadings %>% dplyr::select(name, PC4) %>% arrange(desc(PC4)) %>% head(6)
kable(cbind(a,b,c,d)) %>% kable_styling("condensed", "bordered")
wss <- 0
for (i in 1:15) {
wss[i] <- kmeans(sATM[,vars2], centers = i, nstart = 5)$tot.withinss
}
scree <- tibble(wss, N = 1:15)
ggplot(scree, aes(N, wss)) +
geom_line(size = 1.5, color = base) +
geom_point(size = 3, shape = 21, fill="white", color = base, stroke = 2) +
scale_x_continuous(breaks = c(1:15)) +
labs(title="Screeplot: Number of clusters", x = "Number of clusters", y = "WSS")
set.seed(250920198)
km <- sATM[,vars2] %>%
scale() %>%
kmeans(centers = 4, nstart = 20)
df <- pca$x %>% as_tibble %>% select(PC1, PC2)
df$cluster <- km$cluster
eigen <- pca$rotation
points <- (km$centers) %*% (eigen) %>%
as_tibble %>%
mutate(N=c("PC1", "PC2", "PC3", "PC4")) %>%
gather(variable, value,-N) %>%
spread(key = N, value = value) %>%
mutate(variable2=c(2,1,3,4))
df %>%
ggplot(aes(PC1,PC2)) +
geom_point(aes(color=as.factor(cluster)), alpha=0.3, show.legend = F) +
scale_color_tableau(palette = "Classic Cyclic", type = "regular") +
scale_fill_tableau(palette = "Classic Cyclic", type = "regular") +
geom_point(data = points, aes(PC2,PC1, fill = as.factor(variable2)),
inherit.aes = F, size = 5, shape = 21, color = "black") +
labs(title = "Kmeans clusters displayed in first two PCA components",
subtitle = "Centroids are created by multiplying the centers by the eigen vector from PCA",
fill = "Clusters")
sATM %>%
bind_cols(cluster = km$cluster) %>%
select(vars2, cluster) %>%
select(-atm_street_number, -atm_zipcode, -weather_city_id, -weather_id, -atm_id) %>%
group_by(cluster) %>%
mutate(n = n()) %>%
summarise_all(funs(mean)) %>%
mutate_all(funs(round(.,2))) %>%
kable %>%
kable_styling("condensed", "bordered")
cv <- trainControl(method = "cv", number = 5)
ml <- fbATM
ml$Euro <- as.factor(ifelse(ml$Euro == "TRUE", "Yes", "No"))
index    <- createDataPartition(ml$Euro, p = 0.01, list = FALSE)
training <- ml[index,]
test     <- ml[-index,]
a <- Sys.time()
fit_log <- train(Euro ~ .,
data      = training,
trControl = cv,
method    = "glm",
family    = "binomial",
metric    = 'Accuracy')
b <- Sys.time()
fit_ela <- train(Euro ~ .,
data      = training,
trControl = cv,
tuneGrid  = expand.grid(alpha  = seq(0, 1, by = 0.2),
lambda = 10^seq(1, -4, by = -1)),
method    = "glmnet",
family    = "binomial",
metric    = 'Accuracy')
c <- Sys.time()
fit_tre <- train(Euro ~ .,
data      = training,
trControl = cv,
metric    = "Kappa",
method    = "rpart",
tuneGrid  = expand.grid(cp = c(0.001, 0.005)))
d <- Sys.time()
fit_bag <- train(Euro ~ .,
data      = training,
method    = "treebag",
nbagg     = 50,
metric    = "ROC",
trControl = trainControl(method = "cv", number = 5, classProbs = T))
e <- Sys.time()
fit_raf <- train(Euro ~ .,
data      = sample_n(training, 2000),
trControl = cv,
.mtry     = 6,
ntree     = 100,
method    = 'rf',
metric    = 'Accuracy')
f <- Sys.time()
fit_svm <- train(Euro ~ .,
data      = sample_n(training, 500),
trControl = cv,
tuneGrid  = expand.grid(C = 10^seq(1, -1, by = -0.02)),
method    = 'svmLinear',
metric    = 'Accuracy')
g<- Sys.time()
cat(paste0("Size of training set: ",nrow(training)," rows of 2.5m\n","\n",
"Logistic: ", round(difftime(b,a, units = "mins"),2),"\n",
"Elastic:  ", round(difftime(c,b, units = "mins"),2),"\n",
"Tree:     ", round(difftime(d,c, units = "mins"),2),"\n",
"Bagged:   ", round(difftime(e,d, units = "mins"),2),"\n",
"RF:       ", round(difftime(f,e, units = "mins"),2),"\n",
"SVM:      ", round(difftime(g,f, units = "mins"),2),"\n",
"Total:    ", round(difftime(g,a, units = "mins"),2),"\n"))
a <- Sys.time()
conf_bag <- table(predict(fit_bag,  test), test$Euro)
a <- Sys.time()
conf_bag <- table(predict(fit_bag,  test), test$Euro)
conf_tre <- table(predict(fit_tre,  test), test$Euro)
conf_log <- table(predict(fit_log,  test), test$Euro)
conf_ela <- table(predict(fit_ela,  test), test$Euro)
conf_raf <- table(predict(fit_raf,  test), test$Euro)
conf_svm <- table(predict(fit_svm,  test), test$Euro)
random   <- rbinom(n = length(test$Euro), size = 1, prob = mean(training$Euro == "Yes"))
conf_ran <- table(as.factor(if_else(random == 1, "Yes", "No")), test$Euro)
paste("The prediction takes: ", round(difftime(Sys.time(), a, units = "mins"),2), " mins")
kable(cbind(conf_bag, conf_tre, conf_log, conf_ela, conf_raf, conf_svm, conf_ran)) %>%
kable_styling("bordered", "condensed", font_size = 11) %>%
column_spec(1, bold = T, color="black") %>%
add_header_above(c(" "                             = 1,
"Bagged\nTree"                  = 2,
"Classification\nTree"          = 2,
"Logistic\nRegression"          = 2,
"Elastic Net\nRegression"       = 2,
"Random\nForrest"               = 2,
"Support Vector\nMachines"      = 2,
"Random\nAssignment"            = 2))
bag <- rbind(spec(conf_bag), precision(conf_bag), accuracy(conf_bag), recall(conf_bag), npv(conf_bag))
tre <- rbind(spec(conf_tre), precision(conf_tre), accuracy(conf_tre), recall(conf_tre), npv(conf_tre))
raf <- rbind(spec(conf_raf), precision(conf_raf), accuracy(conf_raf), recall(conf_raf), npv(conf_raf))
log <- rbind(spec(conf_log), precision(conf_log), accuracy(conf_log), recall(conf_log), npv(conf_log))
ela <- rbind(spec(conf_ela), precision(conf_ela), accuracy(conf_ela), recall(conf_ela), npv(conf_ela))
ran <- rbind(spec(conf_ran), precision(conf_ran), accuracy(conf_ran), recall(conf_ran), npv(conf_ran))
svm <- rbind(spec(conf_svm), precision(conf_svm), accuracy(conf_svm), recall(conf_svm), npv(conf_svm))
bag$model <- "Bagged Tree"
tre$model <- "Classification Tree"
raf$model <- "Random Forrest"
log$model <- "Logistic Regression"
ela$model <- "Elastic Net Regression"
ran$model <- "Random Assignment"
svm$model <- "Support Vector Machines"
df <- rbind(ran, log,ela, tre, bag, svm, raf)
ggplot(df, aes(.metric, .estimate, fill = reorder(model, desc(.estimate)))) +
geom_col(position="dodge", width = 0.6) +
scale_fill_tableau(palette = "Classic Cyclic", type = "regular") +
labs(title="Model performance on predicting Euro transaction",
subtitle="Crossvalidated 1/5 split", fill="Predictive Model")
ggplot(df, aes(.metric, .estimate, fill = reorder(model, desc(.estimate)))) +
geom_col(position="dodge", width = 0.6) +
scale_fill_tableau(palette = "Classic Cyclic", type = "regular") +
labs(title="Model performance on predicting Euro transaction",
subtitle="Crossvalidated 1/5 split", fill="Predictive Models\nrdered by performance")
ggplot(df, aes(.metric, .estimate, fill = reorder(model, desc(.estimate)))) +
geom_col(position="dodge", width = 0.6) +
scale_fill_tableau(palette = "Classic Cyclic", type = "regular") +
labs(title="Model performance on predicting Euro transaction",
subtitle="Crossvalidated 1/5 split", fill="Predictive Models\nordered by performance")
# simple undersampling  ---------------------------------------------------
#Downsampling is done by adding sampling="down" in trainControl
#This time the entire dataset with features is used (fdata)
ml <- fdata
ml$Euro  <- as.factor(ifelse(ml$Euro == "TRUE", "Yes", "No"))
index    <- createDataPartition(ml$Euro, p = 0.75, list = FALSE)
training <- ml[index,]
test     <- ml[-index,]
sub  <- ovun.sample(Euro ~ ., data = training, p = 0.5, method = "under", seed = 1)$data
sub2 <- sample_n(sub, 20000)
sub3 <- sample_n(sub, 5000)
sub4 <- sample_n(sub, 100)
a <- Sys.time()
fit_log <- train(Euro ~ .,
data      = sub3,
trControl = cv,
method    = "glm",
family    = "binomial",
metric    = 'Accuracy')
b <- Sys.time()
fit_ela <- train(Euro ~ .,
data      = sub3,
trControl = cv,
tuneGrid  = expand.grid(alpha  = seq(0, 1, by = 0.2),
lambda = 10^seq(1, -4, by = -1)),
method    = "glmnet",
family    = "binomial",
metric    = 'Accuracy')
c <- Sys.time()
fit_tre <- train(Euro ~ .,
data      = sub3,
trControl = cv,
metric    = "Kappa",
method    = "rpart",
tuneGrid  = expand.grid(cp = c(0.001, 0.005)))
d <- Sys.time()
fit_bag <- train(Euro ~ .,
data      = sub3,
method    = "treebag",
nbagg     = 25,
metric    = "ROC",
trControl = trainControl(method = "cv", number = 5, classProbs = T))
e <- Sys.time()
fit_raf <- train(Euro ~ .,
data      = sub3,
trControl = cv,
.mtry     = 6,
ntree     = 50,
method    = 'rf',
metric    = 'Accuracy')
f <- Sys.time()
fit_svm <- train(Euro ~ .,
data      = sub4,
trControl = cv,
tuneGrid  = expand.grid(C = 10^seq(1, -1, by = -0.02)),
method    = 'svmLinear',
metric    = 'Accuracy')
g <- Sys.time()
conf_log <- table(predict(fit_log,  test), test$Euro)
conf_tre <- table(predict(fit_tre,  test), test$Euro)
conf_ela <- table(predict(fit_ela,  test), test$Euro)
conf_bag <- table(predict(fit_bag,  test), test$Euro)
conf_raf <- table(predict(fit_raf,  test), test$Euro)
conf_svm <- table(predict(fit_svm,  test), test$Euro)
random   <- rbinom(n = length(test$Euro), size = 1, prob = mean(training$Euro == "Yes"))
conf_ran <- table(as.factor(if_else(random == 1, "Yes", "No")), test$Euro)
kable(cbind(conf_bag, conf_tre, conf_log, conf_ela, conf_raf, conf_svm, conf_ran)) %>%
kable_styling("bordered", "condensed", font_size = 11) %>%
column_spec(1, bold = T, color = "black") %>%
add_header_above(c(" "                             = 1,
"Bagged\nTree"                  = 2,
"Classification\nTree"          = 2,
"Logistic\nRegression"          = 2,
"Elastic Net\nRegression"       = 2,
"Random\nForrest"               = 2,
"Support Vector\nMachines"      = 2,
"Random\nAssignment"            = 2))
cat(paste0("Size of training set: ",nrow(training)," rows of 2.5m\n","\n",
"Logistic: ", round(difftime(b,a, units = "mins"),2),"\n",
"Elastic:  ", round(difftime(c,b, units = "mins"),2),"\n",
"Tree:     ", round(difftime(d,c, units = "mins"),2),"\n",
"Bagged:   ", round(difftime(e,d, units = "mins"),2),"\n",
"RF:       ", round(difftime(f,e, units = "mins"),2),"\n",
"SVM:      ", round(difftime(g,f, units = "mins"),2),"\n",
"Total:    ", round(difftime(g,a, units = "mins"),2),"\n"))
#confusionMatrix(table(conf_dt3, x_test3$Euro))
raf <- rbind(spec(conf_raf), precision(conf_raf), accuracy(conf_raf), recall(conf_raf), npv(conf_raf))
ela <- rbind(spec(conf_ela), precision(conf_ela), accuracy(conf_ela), recall(conf_ela), npv(conf_ela))
tre <- rbind(spec(conf_tre), precision(conf_tre), accuracy(conf_tre), recall(conf_tre), npv(conf_tre))
log <- rbind(spec(conf_log), precision(conf_log), accuracy(conf_log), recall(conf_log), npv(conf_log))
bag <- rbind(spec(conf_bag), precision(conf_bag), accuracy(conf_bag), recall(conf_bag), npv(conf_bag))
ran <- rbind(spec(conf_ran), precision(conf_ran), accuracy(conf_ran), recall(conf_ran), npv(conf_ran))
svm <- rbind(spec(conf_svm), precision(conf_svm), accuracy(conf_svm), recall(conf_svm), npv(conf_svm))
bag$model <- "Bagged Tree"
tre$model <- "Classification Tree"
raf$model <- "Random Forrest"
log$model <- "Logistic Regression"
ela$model <- "Elastic Net Regression"
ran$model <- "Random Assignment"
svm$model <- "Support Vector Machines"
df <- rbind( log, tre, bag, svm, raf, ran, ela)
ggplot(df, aes(.metric, .estimate, fill = reorder(model, desc(.estimate)))) +
geom_col(position = "dodge", width = 0.6) +
scale_fill_tableau(palette = "Classic Cyclic", type = "regular") +
labs(title = "Model performance on predicting Euro transaction",
subtitle = "Crossvalidated 1/5 split - Under/down sampeling",
fill = "Predictive Models\nordered by performance")
