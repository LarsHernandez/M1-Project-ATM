---
title: "Project M1"
author: "Andreas, Simon, Jess, Lars"
date: "14/9/2019"
output:
  html_document:
    code_folding: hide
    theme: flatly
    toc: yes
    toc_float:
      collapsed: no
---

# Analisys of SparNord ATM transactions in 2017 
Predictive moddeling of EURO vs. Non-EURO transactions
```{r}
#pacman::p_load(tidyverse, ggforce, caret, VIM, gridExtra, 
#               ggmap, osmdata, sf, geosphere, yardstick, 
#               knitr, ggthemes, ggridges, kableExtra)
```


```{r}
library(tidyverse)
library(ggforce)
library(caret)
library(yardstick)
library(knitr)
library(ggthemes)
library(ggridges)
library(kableExtra)
library(gridExtra)
library(VIM)
library(ggridges)
library(ggmap)
library(osmdata)
library(sf)
library(GGally)
library(FactoMineR)
#library(factoextra)
library(geosphere)
library(sf)


load(file="generated_data/sATM.Rdata")
load(file="generated_data/bATM.Rdata")

set.seed(20092019)
```


## Data

```{r fig.height=6, fig.width=10}
coord <- as.matrix(data.frame(min = c(8, 55), 
                              max = c(13, 58), 
                              row.names = c("x","y")))

s <- bATM %>% filter(atm_lat > coord[2,1] & atm_lat < coord[2,2] & 
                     atm_lon < coord[1,2] & atm_lon > coord[1,1]) %>% 
  group_by(atm_id) %>% 
  summarize(n   = n(),
            lat = first(atm_lat),
            lon = first(atm_lon),
            man = first(atm_manufacturer))


# First map ---------------------------------------------------------------
map9  <- get_stamenmap(coord, zoom = 9,  maptype = "toner-lite", force = TRUE)

p1 <- ggmap(map9) +
  geom_point(data = s, aes(lon,lat, size=n), alpha = 0.8) + 
  scale_size(range = c(0.5, 8)) +
  labs(title="SparNord ATM transactions in 2017", 
       subtitle = "size equals number of transactions")

p2 <- ggmap(map9) +
  stat_density_2d(data = s, aes(lon,lat, fill = stat(level)), geom = "polygon", alpha = .3) +
  scale_fill_viridis_c(option = "magma") +
  labs(title="SparNord ATM transactions in 2017", 
       subtitle = "Density of ATM placement")

grid.arrange(p1,p2, nrow=1)
```



```{r fig.height=3, fig.width=10}
s1 <- bATM %>% group_by(month)   %>% summarize(n=n()/1000) %>% ggplot(aes(month,n))   + geom_col()     + labs(title = "obs by month")+ theme(axis.text.x = element_text(angle = 90, vjust=-0.1))
s2 <- bATM %>% group_by(day)     %>% summarize(n=n()/1000) %>% ggplot(aes(day,n))     + geom_col()         + labs(title = "obs by day")
s3 <- bATM %>% group_by(weekday) %>% summarize(n=n()/1000) %>% ggplot(aes(weekday,n)) + geom_col() + labs(title = "obs by weekday")+ theme(axis.text.x = element_text(angle = 90, vjust=-0.1))
s4 <- bATM %>% group_by(hour)    %>% summarize(n=n()/1000) %>% ggplot(aes(hour,n))    + geom_col()       + labs(title = "obs by hour") + scale_x_continuous(breaks=c(0,2,4,6,8,10,12,14,16,18,20,22,24))

grid.arrange(s1,s2,s3,s4, nrow=1)
```


```{r fig.height=3, fig.width=10}
bATM$Euro <- as.factor(ifelse(bATM$currency=="DKK", FALSE, TRUE))
s5 <- bATM %>% filter(Euro == T) %>% group_by(month) %>% summarize(n=n()) %>% ggplot(aes(month,n)) + geom_col()

grid.arrange(s5)

#fATM %>% 
#  group_by(atm_id) %>% 
#  summarize(n=n(), area = first(weather_city_name)) %>% 
#  ggplot(aes(reorder(atm_id,n), n, fill=as.factor(area))) + 
#  geom_col()
```








## Feature generation

```{r eval=FALSE, message=FALSE, warning=FALSE}
# Features for the data ---------------------------------------------------
#sATM <- bATM

# Holidays ----------------------------------------------------------------
# Ferie i Nordjylland (http://skoleferie-dk.dk/skoleferie-nordjylland/)

Vinter <- ifelse(( sATM$month == "February" & 11 <= sATM$day & sATM$day <= 26), TRUE, FALSE)
Paaske <- ifelse(( sATM$month == "April"    & 8  <= sATM$day & sATM$day <= 17), TRUE, FALSE)
Efter  <- ifelse(( sATM$month == "October"  & 14 <= sATM$day & sATM$day <= 22), TRUE, FALSE)
Jul    <- ifelse(((sATM$month == "December" & 20 <= sATM$day) | (sATM$month=="January" & sATM$day<=4)), TRUE, FALSE)
Sommer <- ifelse(((sATM$month == "June"     & 23 <= sATM$day) | (sATM$month=="July"    & sATM$day>=1)| (sATM$month=="August" & sATM$day<=13)), TRUE, FALSE)
sATM$Holliday <- Jul | Vinter | Paaske | Sommer | Efter

# Distance to other ATMs --------------------------------------------------

mat <- as.matrix(data.frame(lon = sATM$atm_lon, 
                            lat = sATM$atm_lat))

Aal.luft <- c(9.842829962, 57.088999644)
Bil.luft <- c(9.150999396, 55.73749705)
Cph.luft <- c(12.650462,   55.620750)

#Distance is in meter and a straight line:
sATM$Aal.luft <- distHaversine(mat, Aal.luft, r = 6378137)
sATM$Bil.luft <- distHaversine(mat, Bil.luft, r = 6378137)
sATM$Cph.luft <- distHaversine(mat, Cph.luft, r = 6378137)

#Nearest airport in km:
sATM <- sATM %>% 
  mutate(Airportdist = round(pmin(sATM$Aal.luft,sATM$Bil.luft,sATM$Cph.luft)/1000,2))

#Divid clock
sATM$Time <- ifelse((sATM$hour >= 4  & sATM$hour <= 9),  "Morning", NA)
sATM$Time <- ifelse((sATM$hour >= 10 & sATM$hour <= 15), "Midday",  sATM$Time)
sATM$Time <- ifelse((sATM$hour >= 16 & sATM$hour <= 21), "Evening", sATM$Time)
sATM$Time <- ifelse((sATM$hour >= 22 | sATM$hour <= 3),  "Night",   sATM$Time)

#Divid the days
sATM$Weekend <- ifelse(sATM$weekday == "Saturday" | sATM$weekday == "Sunday", TRUE, FALSE)
#Valuta
sATM$Euro <- as.factor(ifelse(sATM$currency=="DKK", FALSE, TRUE))
#Payout
sATM$Payout <- ifelse((sATM$day <=4 | sATM$day >= 27), TRUE, FALSE)
#Customer
sATM$Customer <- str_detect(sATM$card_type, pattern = "on-us")
#Cardtype
sATM$Card <- sapply(strsplit(sATM$card_type, split = ' - on-us', fixed = TRUE), function(x) (x[1]))
sATM$Card <- as.factor(sATM$Card)

#Region
loc <- sATM %>% group_by(atm_id) %>% 
  summarize(x=first(atm_lon), y=first(atm_lat))

reg <- NA
for (i in 1:nrow(loc)) {
  aa <- read_csv(paste0("http://dawa.aws.dk/kommuner/reverse?x=",loc$x[i] ,"&y=",loc$y[i]))
  reg[i] <- as.character(aa[10,])
}
loc$Region <- reg

sATM <- merge(sATM,loc[,c(1,4)],by ="atm_id")
sATM$Region <- sapply(strsplit(sATM$Region, split='": "', fixed=TRUE), function(x) (x[2]))
sATM$Region <- as.factor(sATM$Region)

sATM$Id       <- as.factor(sATM$atm_id)
sATM$Time     <- as.factor(sATM$Time)
sATM$Holliday <- as.factor(sATM$Holliday)
sATM$Customer <- as.factor(sATM$Customer)
sATM$Weekend  <- as.factor(sATM$Weekend)
sATM$Payout   <- as.factor(sATM$Payout)

#Final dataset
fsATM <- sATM %>% select(Id, Holliday, Airportdist, Time, 
                         Euro, Customer, Card, Weekend, Payout, Region)

save(fsATM, file = "generated_data/fsATM.Rdata")
```


### Control of Features

```{r}
load(file = "generated_data/fsATM.Rdata")
load(file = "generated_data/fbATM.Rdata")
```




```{r}
fbATM %>% 
  group_by(Euro) %>% 
  summarize(MeanDistance = mean(Airportdist)) %>% kable
```





```{r}
tab <- table(fbATM$Holliday, fbATM$Euro)
tab %>% kable
paste0("Proportion of non-EURO transactions during vacations ", round(tab[2,1] / sum(tab[,1]),2),"%")
paste0("Proportion of EURO transactions during vacations ", round(tab[2,2] / sum(tab[,2]),2),"%")
summary(tab)

```



```{r fig.height=3, fig.width=10}
table(fbATM$Euro, fbATM$Id) %>% 
  prop.table(margin=2) %>% 
  as.data.frame %>% 
  filter(Var1==T) %>% 
  ggplot(aes(reorder(Var2, Freq), Freq)) + 
  geom_col() + 
  labs(x="ATM id", legend="Euro", title="Percentage of EURO transactions by each ATM machine", 
       subtitle="") + theme(axis.text.x=element_text(size=4))
```





## Unsupervised Models

```{r message=FALSE, warning=FALSE, paged.print=FALSE}

vars <- c("day","hour","atm_id","atm_street_number","atm_zipcode","atm_lat",
          "atm_lon","message_code","weather_lat","weather_lon","weather_city_id",
          "temp","pressure","humidity","wind_speed","wind_deg","rain_3h",
          "clouds_all","weather_id")

```

```{r fig.height=6, fig.width=10}
ggcorr(sATM[vars], label = TRUE, label_size = 2, label_round = 2, hjust = 0.90) + 
  labs(title="Correlation among variables", legend="Correlation") + theme_grey() + coord_cartesian(expand=T)

unique(sATM$message_code)
summary(sATM$message_code)

sATM[,vars] %>% 
  aggr(col = c('navyblue','red'), 
       numbers = TRUE, 
       sortVars = TRUE, 
       labels = names(sATM[,vars]), 
       cex.axis = 0.5, 
       gap = 0.5, 
       ylab=c("Histogram of missing data","Pattern"))
```

### Principle Component Analisys (PCA)

```{r fig.height=3, fig.width=10}
#sATM <- sATM %>% select(-weather_lat, -weather_lon)
vars2 <- c("day","hour","atm_id","atm_street_number","atm_zipcode","atm_lat",
           "atm_lon","weather_city_id","temp","pressure","humidity","wind_speed",
           "wind_deg","clouds_all", "weather_id")

pca <- sATM[,vars2] %>% 
  map_dfc(.f = scale) %>% 
  prcomp(rank=4)

summary(pca)

a <- summary(pca)
df1 <- a$importance[2,] %>% as_tibble %>% gather(variable, value) %>% mutate(type="Change", N=c(1:nrow(.)))
df2 <- a$importance[3,] %>% as_tibble %>% gather(variable, value) %>% mutate(type="Accumulated", N=c(1:nrow(.)))

rbind(df1,df2) %>% as_tibble %>% 
  ggplot(aes(N, value)) + 
  geom_line(size=1.5, color="#4f6980") + 
  geom_point(size=3, shape=21, fill="white", color="#4f6980", stroke=2) + 
  facet_wrap(~type) + scale_x_continuous(breaks=c(0:15)) + 
  labs(title="PCA")



loadings <- pca$rotation %>% 
  abs() %>% 
  sweep(2, colSums(.), "/") %>% 
  as.data.frame %>% 
  rownames_to_column("name")

loadings[,-1] <- apply(loadings[,-1], MARGIN = 2, FUN = round, digits=2)

a <- loadings %>% dplyr::select(name, PC1) %>% arrange(desc(PC1))
b <- loadings %>% dplyr::select(name, PC2) %>% arrange(desc(PC2))
c <- loadings %>% dplyr::select(name, PC3) %>% arrange(desc(PC3))
d <- loadings %>% dplyr::select(name, PC4) %>% arrange(desc(PC4))

kable(cbind(a,b,c,d)) %>% kable_styling()


#pca1 <- sATM[,vars2] %>%
#  PCA(scale.unit = TRUE, graph = FALSE)
#
#pca1 %>% 
#  fviz_screeplot(addlabels = TRUE, 
#                 ncp = 10, 
#                 ggtheme = theme_gray())

```


```{r}
sATM[,vars2] %>% 
  aggr(col = c('navyblue','red'), 
       numbers = TRUE, 
       sortVars = TRUE, 
       labels = names(sATM[,vars]), 
       cex.axis = 0.5, 
       gap = 0.5, 
       ylab=c("Histogram of missing data","Pattern"))
```

```{r}
#pca2 %>% 
#  fviz_screeplot(addlabels = TRUE, 
#                 ncp = 10, 
#                 ggtheme = theme_gray())

```


```{r}

#sATM %>% select(-rain_3h,-weather_lon, -weather_lat, -message_code, -message_text)
  
#sATM[,vars2] %>% 
#  scale() %>%
#  fviz_nbclust(kmeans, method = "wss")  

```

```{r}
#km %>% 
#  fviz_cluster(data = sATM[,vars2],
#               ggtheme = theme_gray()) 

wss <- 0
for (i in 1:15) {
  wss[i] <- kmeans(sATM[,vars2], centers = i, nstart=20)$tot.withinss
}

scree <- tibble(wss, N=1:15)

ggplot(scree, aes(N, wss)) + 
  geom_line(size=1.5, color="#4f6980") + 
  geom_point(size=3, shape=21, fill="white", color="#4f6980", stroke=2) + 
  scale_x_continuous(breaks=c(1:15)) + 
  labs(title="Scree plot of number of clusters", x="Number of clusters", y="WSS")
```

```{r}
sATM %>%
  bind_cols(cluster = km$cluster) %>%
  select(vars2, cluster) %>%
  group_by(cluster) %>%
  mutate(n = n()) %>%
  summarise_all(funs(mean)) %>% 
  kable
```


```{r}
#hc <- sATM[,vars2] %>%
#  hcut(hc_func = "hclust", 
#       k = 4, 
#       stand = TRUE)

#hc %>%
#  fviz_dend( k=4 ,rect = TRUE, cex = 0.5)
```






```{r fig.height=6, fig.width=10}
km <- sATM[,vars2] %>% 
  scale() %>% 
  kmeans(centers = 4, nstart = 20) 

df <- pca$x %>% as_tibble %>% select(PC1, PC2)
df$cluster <- km$cluster
eigen <- pca$rotation

points <- (km$centers) %*% (eigen) %>% 
  as_tibble %>% 
  mutate(N=c("PC1", "PC2", "PC3", "PC4")) %>% 
  gather(variable, value,-N) %>% 
  spread(key = N, value = value) %>% 
  mutate(variable2=c(2,1,4,3))

df %>% 
  ggplot(aes(PC1,PC2)) + 
  geom_point(aes(color=as.factor(cluster)), alpha=0.3, show.legend = F) + 
  scale_color_tableau(palette = "Classic Cyclic", type = "regular") + 
  scale_fill_tableau(palette = "Classic Cyclic", type = "regular") + 
  geom_point(data=points, aes(PC2,PC1, fill=as.factor(variable2)), inherit.aes = F, size=5, shape=21, color="black") + 
  labs(title="Kmeans clusters displayed in first two PCA components", 
       subtitle="Centroids are created by multiplying the centers by the eigen vector from PCA", 
       fill = "Clusters")
```
















## Supervised Models

```{r}
cv <- trainControl(method = "cv", number = 5)


ml <- fbATM


index    <- createDataPartition(ml$Euro, p = 0.15, list = FALSE)
training <- ml[index,] 
test     <- ml[-index,] 
```

```{r}
a <- Sys.time()
fit_log <- train(Euro ~ .,
                 data      = training,
                 trControl = cv, 
                 method    = "glm", 
                 family    = "binomial",
                 metric    = 'Accuracy')
Sys.time() - a

conf_log <- table(predict(fit_log,  test), test$Euro)
conf_log


conf_log <- table(predict(fit_log,  test), test$Id)
conf_log
```





```{r}

#conf_raf <- table(predict(fit_raf,  test), test$euro)
#conf_raf

conf_log <- table(predict(fit_log,  test), test$Euro)
conf_log
#
#conf_lok <- table(predict(fit_lok,  test), test$euro)
#conf_lok
#
#conf_net <- table(predict(fit_net,  test), test$euro)
#conf_net
#
#conf_svm <- table(predict(fit_svm,  test), test$euro)
#conf_svm

random   <- rbinom(n = length(test$Euro), size = 1, prob = mean(as.logical(training$Euro)))
conf_ran <- table(as.factor(if_else(random == 1, "TRUE", "FALSE")), test$Euro)
conf_ran
```







```{r}
#raf <- rbind(spec(conf_raf), precision(conf_raf), accuracy(conf_raf))
#net <- rbind(spec(conf_net), precision(conf_net), accuracy(conf_net), recall(conf_net), npv(conf_net))
#raf <- rbind(spec(conf_raf), precision(conf_raf), accuracy(conf_raf), recall(conf_raf), npv(conf_raf))
log <- rbind(spec(conf_log), precision(conf_log), accuracy(conf_log), recall(conf_log), npv(conf_log))
#lok <- rbind(spec(conf_lok), precision(conf_lok), accuracy(conf_lok), recall(conf_lok), npv(conf_lok))
ran <- rbind(spec(conf_ran), precision(conf_ran), accuracy(conf_ran), recall(conf_ran), npv(conf_ran))
#svm <- rbind(spec(conf_svm), precision(conf_svm), accuracy(conf_svm), recall(conf_svm), npv(conf_svm))

#raf$model <- "Random Forrest"
#net$model <- "Elastic Net Regression"
#raf$model <- "Random Forrest"
log$model <- "Logistic Regression - glm"
#lok$model <- "Logistic Regression - glmnet"
ran$model <- "Random Assignment"
#svm$model <- "Support Vector Machine Model"

#df <- rbind(log, lok, ran, net, raf, svm)

df <- rbind(ran, log)

ggplot(df, aes(.metric, .estimate, fill = reorder(model, desc(.estimate)))) + 
  geom_col(position="dodge", width = 0.6) + 
  scale_fill_tableau(palette = "Hue Circle", type = "regular") + 
  labs(title="Model performance on predicting Legendary status", 
       subtitle="Crossvalidated 1/5 split", fill="Predictive Model")
```































